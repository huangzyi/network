# 作业
##1. `172.19.32.0/24`能容纳多少台电脑, 那`172.19.32.0/23`能容纳多少台呢?
	* 24:32 - 24 - 1 = 7 ; 2^7 = 128 ;
	* 23:32 - 23 - 1 = 8 ; 2^6 = 256 ;

##2. 设计一个能容纳256台电脑的网络

	<a href = "./socket.php">socket.php</a>

##3. 简述常用http状态码含义

<dl>

<dt>成功2×× 成功处理了请求的状态码。</dt>
<dd>200 服务器已成功处理了请求并提供了请求的网页。</dd>
<dd>204 服务器成功处理了请求，但没有返回任何内容。</dd>

<dt>重定向3×× 每次请求中使用重定向不要超过 5 次。</dt>
<dd>301 请求的网页已永久移动到新位置。当URLs发生变化时，使用301代码。 搜索引擎索引中保存新的URL。<</dd>
<dd>302 请求的网页临时移动到新位置。搜索引擎索引中保存原来的URL。</dd>
<dd>304 如果网页自请求者上次请求后没有更新，则用304代码告诉搜索引擎机器 人，可节省带宽和开销。</dd>

<dt>客户端错误4×× 表示请求可能出错，妨碍了服务器的处理。</dt>
<dd>400 请求出现语法错误。</dd>
<dd>401 没有访问权限。</dd>
<dd>403 服务器拒绝执行该请求。</dd>
<dd>404 定的页面不存在。</dd>
<dd>405 请求方法对指定的资源不适用</dd>
<dd>406 客户端无法接受相应数据"</dd>
<dd>408 等待请求时服务器超时</dd>
<dd>409 请求与当前资源的状态冲突，导致请求无法完成</dd>
<dd>410 请求的资源永久删除后，服务器返回此响应。该代码与404（未找到）代码相似，但在资源以前存在而现在不存在的情况下，有时用来替代404 代码。如果资源已永久删除，应当使用 301 指定资源的新位置。</dd>

<dt>服务器错误5×× 表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</dt>
<dd>500 服务器遇到错误，无法完成请求。</dd>
<dd>501 服务器不具备执行该请求所需的功能</dd>
<dd>502 网关或代理服务器从上游服务器收到的响应无效</dd>
<dd>503 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</dd>
<dd>504 在等待上游服务器响应时，网关或代理服务器超时</dd>
<dd>505服务器不支持请求中所用的 http 版本",</dd>
</dl>

##4. tcp是如何建立可靠的连接, 如何断开连接的呢?

  - 建立连接
    + TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答TCP的三次握手SYN+ACK，并最终对对方的SYN执行ACK确认。这种建立连接的方法可以防止产生错误的连接，TCP使用的流量控制协议是可变大小的滑动窗口协议。TCP三次握手的过程如下：

      1. 客户端发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。
      2. 服务器端收到SYN报文，回应一个SYN （SEQ=y）ACK(ACK=x+1）报文，进入SYN_RECV状态。
      3. 客户端收到服务器端的SYN报文，回应一个ACK(ACK=y+1）报文，进入Established状态。
三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。

  - 断开连接
    + 建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的半关闭（half-close）造成的。
	  1.  某个应用进程首先调用close，称该端执行“主动关闭”（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。
	  2.  接收到这个FIN的对端执行 “被动关闭”（passive close），这个FIN由TCP确认。
 	 _注意：FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。_

	  3.  一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。
	  4.  接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。
既然每个方向都需要一个FIN和一个ACK，因此通常需要4个分节。

##5. OSI七层模型与TCP/IP四层模型的异同是什么?

  - 异：
	1. OSI七层模型属于理论模型，TCP4层模型属于实际应用的工业标准模型；
	2. osi划分的层次比tcp模型更多,OSI 模型有七层，而TCP/IP 只有四层；
	3. 在于无连接的和面向连接的通信范围有所有同，OSI模型的网络层同时支持无连接和面向连接的通信，但是传输层上只支持面向连接的通信。TCP/IP 模型的网络层只有一种模式即无连接通信，但是在传输层上同时支持两种通信模式。
  - 同：两者都以协议的概念为基础，并且协议中的协议彼此相互独立，而且两个模型中都采用了层次结构的概念，各个层的功能也大体相似。
	1. 前者应用层、表示层和会话层的功能对应tcp模型应用层功能；
	2. 前者传输层对应tcp模型传输层的功能；
	3. 前者网络层对应tcp模型网际层的功能；
	4. 前者数据链路层和物理层对应tcp模型网络接口层功能。

##6. socket和ajax相比有什么异同和**优劣**和哪种**业务环境**采用哪种?

  - 异同
	+ 征询都很快
	+ socket长连接，ajax轮询短连接。
  - 优劣
	+ Ajax兼容性好，socket兼容性差。 
	+ ajax每次通信都需要一个新的HTTP请求，如果数据交互频繁，服务器就需要处理很多HTTP请求。而且，HTTP请求头中会发送Cookie等一些不必要的数据，这会浪费了大量带宽。
	+ WebSocket功能强大、双向、低延迟，且易于处理错误
  - 业务环境：面向的用户群使用的浏览器大部分都为高版本IE时或如果客户端的程序有数据实时同步的需求时使用。

##7. 使用UDP的好处是什么
   * UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。